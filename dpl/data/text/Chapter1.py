#!/usr/bin/env python
# coding: utf-8

# # 1 本書の概要とPythonの基礎

# 本書では、全体を通じて、主にデータサイエンス（データ分析）について学んでいきます。1章ではまず、データサイエンスとは具体的にどんなことをするのか、またそのためにはどんな知識が必要なのかを解説していきます。本書の各章で扱っていることの概要や、読み方などを説明するので、全体像をつかんでください。後半では、Jupyter Notebookを使ってPythonの基礎を学んでいきます。
# 
# ゴール：この書籍の目的を理解する。データ分析の流れを抑え、習得しなければならないことを知る。Jupyter Notebookを使ってPythonの基礎的な実装ができる。

# - **[1.1 データサイエンティストの仕事](#1.1-データサイエンティストの仕事)**
#     - [1.1.1 データサイエンティストとは](#1.1.1-データサイエンティストとは)
#     - [1.1.2 データ分析のプロセス](#1.1.2-データ分析のプロセス)
#     - [1.1.3 本書の構成](#1.1.3-本書の構成)
#     - [1.1.4 本書を読み進めるのに役立つ文献](#1.1.4-本書を読み進めるのに役立つ文献)
#     - [1.1.5 手を動かして習得しよう](#1.1.5--手を動かして習得しよう)
# <br><br>
# - **[1.2 Pythonの基礎](#1.2-Pythonの基礎)** 
#     - [1.2.1 Jupyter Notebookの使い方](#1.2.1-Jupyter-Notebookの使い方)
#     - [1.2.2 Pythonの基礎](#1.2.2-Pythonの基礎)
#     - [1.2.3 リストと辞書型](#1.2.3-リストと辞書型)
#     - [1.2.4 条件分岐とループ](#1.2.4-条件分岐とループ)
#     - [1.2.5 関数](#1.2.5-関数)
#     - [1.2.6 クラスとインスタンス](#1.2.6-クラスとインスタンス)
# <br><br>
# - **[1.3 総合問題](#1.3-総合問題)** 
#     - [■ 総合問題1-1 素数判定](#■-総合問題1-1-素数判定)

# 
# ***

# ## 1.1 データサイエンティストの仕事
# ゴール：この書籍の目的を理解する、データ分析の流れを抑える、習得しなければならないことを知る

# 本書は、データサイエンス（データ分析）を学ぶための基礎を身に付けることを目的にしています。まずは、データサイエンスとは何か、そして、データサイエンスのために必要な知識として、どのようなものがあるのか、その概要を説明します。

# ### 1.1.1 データサイエンティストとは
# キーワード：データサイエンティスト、統計学、プログラミング、エンジニアリング、コンサルティング

# 上で述べたとおり、本書では、全体を通じて、主にデータサイエンスについて学んでいきます。
# そこでまずは、データ分析の専門家である「データサイエンティスト」について考えてみましょう。この言葉は、さまざまな書物やネット上で定義されており、一概にはまだ定まっていませんが、本書においては、**ビジネスの課題に対して、統計や機械学習（数学）とプログラミング（IT）スキルを使って、解決する人**と定義します。

# （※図は書籍を参照してください※）

# データサイエンティストは、数学や統計のエキスパートでなければなれないと思われがちですが、そうではありません。確かに、数学や統計の知識は必要です。しかしそれだけではなく、それを実装できるエンジニアリング能力も必要です。具体的には、ここで学ぶPythonで実装する力です。また、そもそもそれらを使ってビジネス課題を解決していくためのコンサルティング能力も求められています。これらのうち、どれか1つが欠けてもデータサイエンティストではありません。しかしすべての分野においてエキスパートであることが求められるわけではありません。求められるのは、統合的な能力です。これらのスキルについて、すべてエキスパートだという人はいませんし、それぞれの強みを持っている人たちでグループを作り、データサイエンスチームを結成することもあります。
# 
# データサイエンティストが、どのようにしてデータ分析の課題を実際に解決していくのかなど、より詳しいことについては、巻末の参考文献「A-1」に掲載しているような各種データ分析関連の書物を、ぜひ読んでみてください。

# ### 1.1.2 データ分析のプロセス
# キーワード：データ分析のプロセス、PDCA

# では、データサイエンティストは、データをどのようなステップで分析すればよいのでしょうか。
# データ分析では、データ分析のフローやプロセスを理解し、それを創ることが重要です。たとえば、ビジネスデータを分析するプロジェクトでは、そのビジネス理解、データ理解、データ加工、処理、モデリング、検証、運用という流れで進めていくのが一般的です。
# こうした流れのうち、重要度が特に高いのが、ビジネス理解です。ここを外すと、データ分析の意味がなくなってしまいます。
# データ分析には目的があります。分析ありきではありません。しかしクライアントや関係者が、はっきりと目的を持っていないこともあります。その場合は、目的を定めるところから始めることになります。話し合いなどをしながら、データサイエンティスト側から課題を見つけ、提案していくことが求められます。この過程では、プロジェクトメンバー（コンサルタント、営業等）と協力する必要がありますし、またクライアントや関係者ともコミュニケーションをとっていく必要があります。
# 
# そして、こうした流れを回していくことも大事です。どこかの段階が終わったら完了ではなく、サイクルを回し続ける、いわゆるPDCAサイクルの流れまで持っていく必要があります。
# データをどのように分析するのかというモデリングだけにしか興味がない人にとって、こうしたビジネス的な話は面白くないかもしれませんが、これが現実です。
# データサイエンティストの仕事には、こうした側面もあるという現実をお伝えしたうえで、それを、どのようにアプローチしていくのか、どのようにして具体化（実装）するのかを学んでいくのが、この書籍です。

# （※図は書籍を参照してください※）

# >**[ポイント]**
# >
# >データ分析の現場で大事になるのは、ビジネス理解やその目的を明確化し、PDCAサイクルの流れ（データ分析のプロセス）を創ることです。

# データ分析のプロジェクトの流れを学んだり、データ分析のフローや結果のシステム化や実務での運用したりする際に役立つ書籍として、巻末に参考文献「A-2」「A-3」を掲載しています。

# ### 1.1.3 本書の構成
# キーワード：データ分析、Python、線形代数、微分積分学、確率、統計、機械学習

# 本書では、データサイエンティストになるために必要なことを、実際に体験しながら学んでいきます。
# すでに説明したようにデータサイエンティストは、数学や統計の知識のほか、エンジニア力やコンサルティング力も必要になるので、本書の内容も多岐に渡ります。
# 
# 1章から4章の内容が、データ分析のための基礎知識です。
# このあと1章では、データ分析によく使われるプログラミング言語のPythonや、本書に掲載しているサンプルコードを実際に動かせるJupyter Notebookについて説明します。そして2章では、データ分析の際にPythonと組み合わせて使われる科学計算や統計ライブラリであるNumpy、Scipy、Pandas、Matplotlibについて説明します。
# 3章と4章は、数学的な基礎知識を説明する章です。3章では統計学の基本と単回帰分析について、4章では確率と統計の基礎について学びます。4章は、少し理論的なお話になり数式も出てきますが、徐々に慣れてください。
# 
# 5章から7章は、Pythonでデータを扱うための処理方法や可視化を身に付ける章です。
# 5章では科学計算に使われるNumpyやScipy、6章ではデータ加工処理に必要となるPandasを使ったテクニック、そして7章では、データの可視化（Matplotlib）やデータ分析結果の伝え方について学びます。
# この章までにPythonのデータ分析前の処理や加工の基礎を身に付け、総合問題でそれらの手法を活用します。具体的には金融の時系列データやマーケティングデータを例に取り、データ分析の実務現場でも使われている基礎的な手法を紹介します。
# 
# 8章からが機械学習の単元です。つまりモデルを作って学習させていく話です。
# 8章ではあらかじめ答えがわかっているデータに対して学習する、教師あり学習を習得します。そして次の9章では、あらかじめ答えがわかっていない分析のアプローチ、すなわち、教師なし学習を習得します。続く10章では、その機械学習で学んだモデリングを検証したりチューニング（パラメータを変更して、モデルの精度を上げる）したりする方法を学びます。モデルは作ったら終わりではなく、しっかりと検証する必要があるので、学習データにモデルが最適化されすぎる「過剰学習（過学習ともいわれます）」の問題などについても説明します。
# 
# 11章と12章は、まとめの章です。
# 11章ではデータサイエンスの中級者になるために必要なスキル、たとえばPythonの処理の高速化や深層学習入門、分散処理するためのSpark（Pyspark）を少し紹介します。本書はあくまでデータサイエンスの入口で、さまざまなことを幅広く扱っています。大事なのは、その後、学習をさらに深めていくことです。そのための手引きとなる章です。12章は今まで学んだスキルを試すためのまとめの総合問題です。
# 
# これらの章をすべて習得すれば、データ分析に必要な最低限のスキル、そして、今注目されている深層学習などを学ぶための前知識も身に付けることができます。
# 余談ですが、ここでデータ分析のスキルをしっかりと身に付けておけば、自分の市場価値を上げることができますし、就職や転職するときの選択肢が大きく広がります。

# ### 1.1.4 本書を読み進めるのに役立つ文献
# 
# 本書はデータ分析の入門書ではありますが、いま述べたすべての分野について、本当に基礎から説明することはできません。そのため、やむなく、ある程度の基礎知識を前提とします。
# 
# 本書で前提としている知識は、大学で習う微分・積分と線形代数の基礎、そして簡単なプログラミング経験があること（可能ならPython）を想定しています。また、データ分析は確率・統計と深く関わるので、この書籍とは別に、確率と統計の基礎を体系的に学習することをお勧めします。
# 
# 本書では厳密な数式に基づいた内容（集合・位相や測度論に基づいた確率統計）というよりも、データ分析の現場に必要なスキルを身につけるという視点で解説をしています。数式が出ている箇所について、理解が困難な場合もあるかも知れませんが、一度にすべてを理解しなくても先には進むことができます。分からない箇所があったり、気になっている箇所があったら、巻末の参考文献「A-4」や「A-5」、参考URL「B-1」などを都度、参考にしてください。
# 
# なお本書は全体がつながっているので、後から振り返って分かるということもあります。ですから、まずは、少し分からないところがあっても、そこで止まらず、読み進めてみてください。

# 本書では一部、線形代数や微分積分学の基礎知識を前提に話を進めますので、不安がある人は、巻末の参考文献「A-6」などを見て復習してください。後の章でも、固有値などの用語が出てくるので、さらっと読んでおきましょう。
# 
# もちろんすべてを復習する必要はありません。該当の章を実際に試す上で、必要そうな箇所をピックアップしたり、そこで出現する専門用語をネットで調べながら学習を進めてください。さらっと読んでみて、自分にあっている本を1～2冊読めばよいでしょう。
# 
# なお、線形代数や微分積分学に限った話ではありませんが、大学の数学は抽象度が上がり、苦手意識を持つ人が多いようです。問題演習をこなすことによってイメージが付きやすくなるので、参考文献「A-6」の書籍などに掲載されている例題や演習を中心にやってみると理解が高まります。

# 参考文献「A-7」に掲載している書籍は少し高度ですが、大学1～2年の数学に不安のある方、数学的な厳密性を求めたい方にお勧めします。解析学、線形代数、統計学の基礎を一通り学ぶことができます。

# ### 1.1.5  手を動かして習得しよう
# キーワード：自分の手を動かして学ぼう

# ビジネスの理解ができても、それを形にする（実装する）ことができなければ、データサイエンティストではありません。そこで本書では、さまざまなデータに対処して、実装できることを目指します。そこで、学習する上でとても大切になってくるのが、**「自分で考えて手を動かしながら学ぶこと」**です。
# 
# 「はじめに」にも書いたように、本書の大きな特徴として、「実際に手を動かしながらデータ分析の手法が学べるコンテンツがある」という点が挙げられます。本書では、Jupyter Notebookという環境を使って、実際にPythonを使ってデータ分析するプログラムを作り、すぐに試せるようサンプルを提供しています。Jupyter Notebookのインストール方法などはAppendixにまとめていますので、まずはそちらを参照して環境を準備してください。なお、本書のサンプルは、Googleが提供している「Colaboratory」を使っても実行できます。ただし、環境が異なるため、一部、同じように実行できない箇所もあるので、ご了承ください。
# 
# この書籍のサンプルプログラムを使って、実際に変数に入れる値を変更してみたり、コードを実行して、結果をみてください。基本的には、上から順に実行するだけで良いのですが、ただコードを眺めているだけでは、分析やコーディングのスキルは身に付きません。実際に手を動かして試行錯誤することでしか、コーディングスキルは身に付きません。書籍のところどころに、「～をしてみてください」や「考えてください」という文言（**[やってみよう]**）があるので、そうしたところでは、次に進む前に、きちんと立ち止まって考えて、コーディングしてみてください。
# 
# さらに、練習問題などに関わらず、ご自身の中で「ここの数字を変えたり、処理を変えたらどうなんだろう」など、仮説やアイデアが浮かんだらぜひ、いろいろと試してみてください。
# 
# そういったやり方は、時間はかかるかもしれません。やり方がわからなかったり、エラーメッセージなどが返ってきて、詰まる時もあるかもしれません。しかし、エラーメッセージを見ながら、まずは自分で調べながらやることも大事です。またコードが複数行あって、書籍の説明文だけでは分からない処理があるかもしれません。そのときは、1行1行実行して、どういう結果が返ってくるのか、見ていきましょう。そこから1つ1つ学ぶことができるのです（もちろん、簡単だと思われる場合は、適宜スキップしてください）。

# 本書を読み進めていく中で、わからないキーワードやライブラリ名、コードなどが出てくることもあると思います。そのときは、これまであげた参考文献などを見るだけではなく、検索エンジン（Googleなど）を積極的に使って調べていきましょう。はじめは調べたいものがすぐに見つからず、時間がかかるかもしれませんが、慣れてくれば調べるコツも分かってきます。この**調べる力もとても重要**です。
# 
# また、本書に書いてあることをすべて丸暗記しようなどとは思わないでください。
# あくまでも本書は、Pythonを使って、さまざまなデータ加工処理ができるということをまずは知ってもらうためにあり、すべて覚えてもらうことを想定していません。
# 学んだばかりの処理は、すぐに使いこなせないかもしれませんが、必要なテクニックは使う頻度も多くなって、そのうち手が覚えて、自然に使えるようになります。
# 実際、現場で働いている多くのエンジニアは、わからないことがあるときは、ネットで探したり、ネット上にある掲示板で質問して、仕事をしています。
# ですから特に初学者の方は、本書ではさまざまな方法があるというのをまず知って、必要なときに振り返って、使えることが大事です。

# 御託を並べてきましたが、自分で考えてコーディングしたものが動いて、結果が返ってくるというのはとても楽しいです。
# もちろん、単純作業もありますが、それを自動化したり、うまく処理できるスクリプトができたときも快感です。クリエイティブな要素も多いので、ぜひその感触も掴んでください。

# >**[ポイント]**
# >
# >実際にPythonのコードを書いて実行し、結果をみながら、試行錯誤しよう。そして、楽しんでプログラミングしよう。

# なお、Pythonを使った自動処理の入門的な本として、参考文献「A-8」のような本が出版されているので、参考にしてください。昨今流行っているRPAツールも、この本で紹介されているツール（`pyautogui`など）を使えば、作成できます。参考URL「B-2」は、「A-8」の英語版（原本）ですが、無料です。PDF版もあります。フリーの教材や講義は英語であるケースが多いので、ついでに英語の勉強もして、幅広く情報を取得できるようになるとよいでしょう。英語もできるようになると、さらに仕事の幅は広がります。

# ***

# ## 1.2 Pythonの基礎
# ゴール：Jupyter Notebookを使ってPythonの基礎的な実装ができる
# 
# 本書では、データ分析をするためのプログラミング言語としてPythonを使います。そもそもなぜPythonを使うのでしょうか。それは、他のプログラミング言語と比べてコーディングが容易で、さまざまなこと（データの加工、取得、モデリング等）が一貫して簡単にできるからです。このようなデータ解析や機械学習系のライブラリが揃っているのが特徴です。
# 
# こうした理由で、多くのデータサイエンティストが、データ解析にPythonを利用しています。Pythonのユーザーはどんどん増えてきて、Pythonはどんどん進化しています。Pythonの構文は比較的簡単なので、Python以外でプログラムをやってきた人はもちろん、プログラム経験がない人たちでもすぐに扱うことができます。
# 
# なお、PythonにはPython2系とPython3系の2系統があり、文法が一部異なります。Python 2 と3ではコードの書き方が変わっており、本書はPython 3に基づいています。Python 2のサポートは2020年までとなっているため、今後はPython 3を使うことをお薦めします。

# ### 1.2.1 Jupyter Notebookの使い方
# キーワード：Jupyter Notebook、ショートカットキー
# 
# では、Pythonのコードとは、どのようなものでしょうか。早速、Pythonのコードを見て、実行していきましょう。
# Jupyter Notebook（以下Jupytert環境）を使えば、Pythonプログラムの実行は、とても簡単です。コードを入力して実行操作するだけで、その結果が表示されます。他のプログラミング言語で実施するコンパイル（システムが理解できるような機械語に変換する処理）などは基本的に必要ありません。まだJupytert環境を用意していない方はぜひ準備して、実行してください。なお、冒頭でも紹介しましたが、Googleが提供している「Colaboratory」を使うことでも、本書のコンテンツを実行できますので、インターネットができる環境でGoogleのアカウントを持っている人は、このColaboratoryを使ってみてください（ただし一部環境の違いにより、実行できない箇所もあります）。
# 
# 以下、Pythonのコードを実行していきます。なお掲載しているコードは、基本的に上から順に実行してください（後ろで掲載しているコードが、前のコードの実行を前提としたところがいくつかあり、それを途中のコードから実行すると、同じ結果とならないことがあり、またエラーになることもあるので注意してください）。

# まずは、プログラミング言語入門でおなじみの「Hello, world!」を表示させることをやってみます。Pythonなら、次のコードで足ります。他のプログラミング言語は数行必要ですが、Pythonではこの1行だけでよいのです。`print`は画面に出力する関数です。print関数の括弧中に、出力する文字列を指定します。Pythonで文字列を表現するには、「'Hello, world!'」のように全体をシングルクォーテーション（もしくは「"」（ダブルクォーテーション））で囲みます。

# In[ ]:


print('Hello, world!')

# このコードを実際にJupytert環境で実行するには、次のようにします。
# 
# 【手順】　Jupyter環境でPythonのコードを入力し、実行するためのステップ
# 
# ［1］　セル（下記で青くIn[ ]となっている箇所）を追加する
# 
# Jupyter環境では、そのセルにコードや文章を記述します。
# 新規にNotebookを作成したときは、「Untitled」（できたファイルの上記に記載されています。なお、連続して複数作成した場合は、連番が振られてたファイル名となります）という名前のファイルができ、その中に1つのセルがあるはずなので、そこにコードを記述します。もしセルがない場合、もしくは、セルを追加して他のコードをさらに実行したいときなどには、左上にある［+］ボタンをクリックすると、セルを追加できます。
# 
# セルには、「Code」「Markdown」「Raw NBConvert」の3種類があります（メニューには、もうひとつ［Heading］という項目がありますが、これは見出しを作るためのもので［Markdown］の一種です）。コードを実行するには［Code］をクリックしてください。
# 
# ・Code　コードを書く場合（書いたコードを実行できます）
# 
# ・Markdown　文章を書く場合（書いたコードで「#」などで始まる部分は書式化して表示されます）
# 
# ・Raw NBConvert　何も加工せずにそのまま編集・表示します。

# <img src="figures/chap1_03.png">

# ［2］　コードを入力する
# 
# セルの種類を［Code］にしたら、そこに、本書に掲載されているプログラムを入力します。なお、新しくセルを追加したときは、デフォルトでCodeになっています。

# <img src="figures/chap1_01.png">

# ［3］　実行する
# セルをクリックして選択した状態（以下のようにセルが緑色に囲まれます）にしておき、［Run］ボタンをクリックすることでコードを実行できます。もしくは、セルを選択し、［Shift］キー＋［Enter］キーを押すことでも実行できます。
# 実行結果は、すぐ下に表示されます。このときもし、文法エラーがあれば、文法エラーの旨が表示されます。
# ［Shift］キー＋［Enter］キーで実行すると、セルが下にもうひとつ追加されて、さらにプログラムを入力できるようになります。必要なければ、はさみのアイコンをクリックして、そのセルを削除してもかまいません。
# 
# プログラムを修正して再実行したいときは、コードを変更して、もう一度実行すれば、実行結果が変わります。

# <img src="figures/chap1_02_sitei.png">

# 複数行から構成されるコードの入力や実行も同じです。たとえば、次のコードは、足し算（+）、かけ算（\*）、そして、べき乗（\*\*）を計算します。なお、#はコメントアウトで、無視されます。今書いているコードの意味を、将来的に理解するためであったり、第3者がみてもわかりやすいように、適宜、コメントを残すことも大事です。
# ここでは`print`関数を使って出力していますが、`print`関数なしで「`1+1`」や「`2*5`」「`10**3`」のように入力するだけでも同様に出力でき、電卓のようにも使えますが、その場合、最後の行だけ計算結果が表示されます。

# In[ ]:


# 足し算の例
print(1 + 1)

# 掛け算の例
print(2 * 5)

# 10の3乗, べき乗は**を使う
print(10 ** 3) 

# 以下は`print`関数なしで計算して、表示しています。なお、Pythonのスクリプト（ファイル名,pyなど）では、何かコードの計算結果を表示させるのに`print`関数が必要なので注意しましょう。

# In[ ]:


10**3

# Jupyter環境でコードを実行するための最低限の手順は以上です。
# 
# 本書でコードが登場したときは、［＋］を押してセルを追加して、そこにコードを入力して実行してみてください。
# 
# セルを切り取りたい場合は［ハサミ］ボタンを、セルを上下に移動したい時は［↑］［↓］ボタンをクリックします。
# コードを書くときは、いま説明したように「Code」を使いますが、文章などを記述したいときは、「Markdown」を選択してください。メモを残したい場合などに便利です。
# 
# Jupyter環境では、さまざまなアウトプットが作れるので、もし詳しく知りたい人は、巻末の参考URL「B-3」などを見ながら実行することをお勧めします。

# もっとコーディングの効率を高めたいなら、ショートカットキーを使いこなせるようになりましょう。編集モードでない状態（［Esc］キーを押します）で［H］キー押すと以下のような画面が出てくるので、たとえば、新しいセルを下に追加したいときは、［B］キーを押します。他にも、コピー(［C］)、貼り付け(［V］)などもあるので、ぜひ使いこなしてください。ショートカットキーに慣れていない人は、はじめは少し大変かもしれませんが、慣れると圧倒的に作業時間が短くなります。
# 
# たとえばコードが長くなって行番号を表示したいときには、該当をセルを選択し、［Esc］キーを押した後に「L（エル）」キーを押します。すると、行番号が表示されるようになります。

# ![comment](http://www.perfectlyrandom.org/assets/jupyter-keyboard-shortcuts.png)

# >**[ポイント]**
# >
# >作業（コーディング）を効率よく進めるためには、ショートカットキーを使いなそう。

# なお、ショートカットキーを使う場面はJupyter環境だけではありません。ほとんどの人がPCのOSとして、WindowsかMacを使っていると思いますので、それぞれのショートカットキーも使えると作業効率が高まります（Excelなどもそうです）。全く使っていなかった人は、ぜひ使えるようになりましょう。スポーツ（野球やバスケットなど）でいうところの基礎練習（素振り、ドリブルなど）だと思って、手を慣らしてください。なお、ショートカットキーについては、色々ありますので、Googleなどで検索して、調べてみてください。

# ### 1.2.2 Pythonの基礎
# キーワード：演算、文字列、変数

# Jupyter環境でコードを実行する方法がわかったところで、Pythonの基本を、さらに続けます（これから提示するコードは、ぜひ、Jupyter環境に入力して実行してみてください）。
# 
# 次の例は、`msg`という名前の変数に、「test」という文字列を格納し、`print`関数でその変数に格納されている値を表示させるというコードです。文字列を作成するときは、すでに述べたようにシングルクォーテーションまたはダブルクォーテーションで囲みます。
# 
# なお、C言語やJavaなどのプログラミング言語では、変数を扱うときに整数なのか文字なのかを「型」として設定し、これから利用するという宣言をする必要があります（たとえば、`int x` は整数型のxという変数という意味になります）。しかし、Pythonには変数の型宣言が基本的に必要ないので、変数を使いたいときに値を代入するだけで使えます。なお、型がある言語を、静的型付け言語といいます。C言語やJavaなどの言語は静的型付け言語です。

# In[ ]:


msg = 'test'
print(msg)

# 文字列の後ろに「[番号]」を指定すると、文字列の一部を取り出すことができます。これをインデックスと言います。インデックスは0から始まりますので、注意しましょう。たとえば次の例は、`msg`変数の先頭の文字や2番目の文字を取り出すものです。

# In[ ]:


# インデックス0から始まるので1文字目が取り出される
msg[0]

# In[ ]:


# 2番目の文字を取り出したいときのインデックスは1
msg[1]

# 次の例は、インデックス5の文字を取り出そうとしています。これまでの流れでは、`msg`には「test」という4文字の文字列が格納されているので、インデックスの最大は最後の「t」に相当する「3」です。つまり、インデックス5を指定しても、6番目の文字はないので、エラーとなります。

# In[ ]:


# 実行するとエラー
msg[5]

# 今後、コードを書いて、それを実行したあと、エラーに遭遇することは多々あります。この時、プログラミング初心者の方は、思考停止することが多いのですが、その解決の手がかりとなるのが、最後に表示されるエラーメッセージです。上の例では、最後に「`IndexError: string index out of range`」と表示されています。「`IndexError`（インデックスのエラー）」であり、「`string index out of range`」（文字インデックスが範囲外）というメッセージですから、「5の部分はおかしいのかな」ということがわかります。
# 
# 当たり前のことですが、エラーが発生したときは、まずはエラーメッセージを確認しましよう。「----> 」がエラーが発生している場所を指しています。
# エラーメッセージがわからないときは、そのままエラーメッセージをGoogleなどで検索してみましょう。他の人も同じようなエラーに遭遇している可能性は意外と高いので、早く解決策が見つかるかもしれません。

# >**[ポイント]**
# >
# >エラーが発生した時は、慌てずにエラーメッセージをしっかり確認しましょう。わからなければ、そのままエラーメッセージを検索エンジンで探しましょう。

# さて、先ほどは変数に文字を割り当てましたが、もちろん数字を割り当てることもでき、その変数を使って、変数同士の演算も可能です。なお、=は等しいという意味ではなく、右の値を左の値に割り当てるという意味です。

# In[ ]:


#　変数dataにデータ1を割り当て
data = 1
print(data)

# 上の数字に10を足す
data = data + 10
print(data)

# ここでは変数の名前を`data`としましたが、何か変数を作成するときは、可能な限り分かりやすい名前で作成しましょう。ただ、単なる数字のチェックなどをするだけであれば「`a =`」などでも良いですし、実際に、本書でも、一時的に使う変数などには、特に凝った名前は付けていません。
# 
# 大規模な開発になってくるほど変数名は大事です。もちろん、第三者のためにという意味でメリットになりますが、将来の自分のためにもなります。たとえば、変数を書いた直後はどんな変数を割り当てたのか覚えていますが、1週間、1ヶ月後その変数xを見たときに、どうでしょうか。何の変数だったのか忘れてしまうことは多々あります。さらにコードが長くなってくると、変数も増えてきて、わからなくなります。
# 
# コーディングについては、絶対的なルールはないですが、ある程度は規定されているので、ぜひ参考URL「B-5」のサイトなど見て参考にしてください。

# その他、変数作成に関する注意点として、プログラミング言語には、**予約語**といわれる、あらかじめ用意されている変数や組み込みオブジェクトなど(`while`、`if`、`sum`など)がありますので、それらを変数名として使わないように注意しましょう。なお、オブジェクトという言葉は、そのまま訳すると「もの」ですが、データ（や値）とその処理がセットになったものという理解をしてください。後程、オブジェクト指向については説明します。
# 
# 変数名として予約語を使ってしまうと、後からその機能が使えなくなってしまいますので、以下の情報等も参考に、変数名の選択には注意してください。

# In[ ]:


# 予約語
__import__('keyword').kwlist

# In[ ]:


# 組み込みオブジェクト
dir(__builtins__)

# >**[ポイント]**
# >
# >予約語や組み込みオブジェクトなどに注意して変数名を設定しよう。

# ### 1.2.3 リストと辞書型
# キーワード：リスト、辞書型、タプル、集合

# 次は、リストについて説明します。リストとは複数の値をひとまとめにして扱うための仕組みで、他の言語で言うところの配列のようなものです。データ分析では配列のような複数の値を一緒に扱うことが多いため、とてもよく使われます。
# 
# 以下は、1から10まで数字が並んでいるデータを作っています。
# Pythonでリストを表現するには、全体を「[」と「]」で囲んでカンマで区切ります。先頭からn番目の要素は、「変数名`[n]`」のように表記することで取得できます。たとえば、`data_list`という要素の先頭は`data_list[0]`、2番目は`data_list[1]`です。文字列の取り出しのときと同様に、インデックス番号は0から始まります。
# 
# 以下で、`print(data_list)`を実行したときに、`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`と表示されているのがわかると思います。次に`type`関数を使って、`data_list`の変数のタイプを表示しています。これは、`class 'list'`と表示されていますので、リスト型の変数だとわかります。ほか、要素数は`len`関数を使って、「`len(data_list)`」のように表記すると取得できます。

# In[ ]:


# リストを作る
data_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(data_list)

# typeで変数のタイプがわかる
print('変数のタイプ:', type(data_list))

# 1つの要素を取り出す。0から始まるので、[1]は2番目になる
print('2番目の数：', data_list[1])

# len関数で要素の数を出力。ここでは1から10までの10個なので、結果は10。
print('要素数：', len(data_list))

# >**[やってみよう]**
# >
# >Jupyer環境で、Notebook上部の［＋］ボタンをクリックして（もしくは非編集状態で、［B］キーを押して）セルを追加し、何かのリストを作成して、要素数を出力してみましょう。

# なお、リスト内のそれぞれの要素を2倍したい場合、そのリストに2をかけても、リスト全体が、もう一度、繰り返されるだけなので、注意しましょう。それぞれの要素の値を2倍したいのなら、`for`文（後述の内包表記）を書くか、次の章で説明する`Numpy`を使うと良いです。

# In[ ]:


# リスト自体が2倍になる
data_list * 2 

# 他、リストの要素を追加したい場合はappend、削除したい場合にはremoveやpop、delなどを使います（これらはメソッドと呼ばれます）。リストの要素に何かを追加したり削除したい場合は、これらのキーワードを調べてみてください。

# >**[やってみよう]**
# >
# >リストに何か要素を追加したり、削除する方法を調べて、実行してみましょう。

# リスト型と似たものに、辞書型があります。辞書型を使うと、キーと値をペアにして複数の要素を管理することができます。Pythonで辞書を表現するには、全体を「{」と「}」で囲んで、`{キー:値}`のようにコロン区切りで表記します。キーは整数だけではなく、文字列でも指定できます。またリストとは違って、順番は特に関係ありません。
# 
# 次の例のように、「appleが100」「bananaが100」「orangeが300」などのように、何か指定したキーに対して値を保持させたいときに使います。値を参照するときは、`辞書データ[キー名]`というように表記します。以下では、辞書型のデータを用意した後に、`melon`というキーを参照して、それに対応する500が表示されているところです。

# In[ ]:


# 辞書型
dic_data = {'apple': 100, 'banana': 100, 'orange': 300, 'mango': 400, 'melon': 500}
print(dic_data['melon'])

# >**[やってみよう]**
# >
# >上では、melonを表示させましたが、orangeの値を表示させてみましょう。また、キーがappleとorangeの値を足してみましょう。

# 辞書型のデータも、要素を追加したり、削除したい場合があります。その方法を調べて実行してみてください。

# >**[やってみよう]**
# >
# >辞書のデータに、何か新しい要素を追加したり、削除する方法を調べて、実行してみましょう。

# 以上がリストと辞書の解説になります。
# 
# 他、pythonのデータには**タプル**や**集合**などもありますので、調べてみてください。本書ではメインで使いませんが、少し使う場面があるので、それまでにどのようなものか把握しておきましょう。

# >**[やってみよう]**
# >
# >Pythonのタプルや集合についてそれらの役割や使い方について調べて、使ってみましょう。

# ### 1.2.4 条件分岐とループ
# キーワード：真と偽、比較演算子、and、or、not、条件分岐、if、ループ処理、for、制御、内包表記、オブジェクト指向、break、continue

# Pythonでは書いたプログラムが上から下に向けて実行されるのが基本ですが、その流れを変えて、条件分岐や繰り返しの処理をするための構文があります。
# 
# #### 比較演算子と真偽判定
# まず条件分岐やループ処理を扱う前に、比較演算子と真偽の判定について解説します。ここでは、ある式が成立している（真、もしくは、`True`）のか、成立していない（偽、もしくは、`False`）のか判定する方法を説明します。以下では、数字の1と1が等しいかを判定しています。ある値と値が等しいのかを判定するために、イコールを2つ（`==`）書いています。これが比較演算子です。実行した結果は`True`になっており、これは真になります。

# In[ ]:


1 == 1

# 一方、1と2は等しくないので、`False`になり、偽となります。

# In[ ]:


1 == 2

# 次は、1と2は等しくないという意味で、イコールの前にビックリマークを付けています。1と2は等しくないのは正しいので、これは真になります。

# In[ ]:


1 != 2

# 比較演算子には、イコールのほかに、大小記号（＜や＞）もあります。以下の1つ目のセルには、1は0より大きいのかを判定しており、これは真になります。次は、1は2より大きいかどうかを判定していますが、これは成り立たないので偽になります。

# In[ ]:


1 > 0

# In[ ]:


1 > 2

# 真偽の判定は、複数の条件を組み合わせることもできます。。次の例は、2つの条件式が両方成り立っている場合に真になる`and`を使って判定するものです。どちらの式も成り立っているので、`True`になります。

# In[ ]:


(1 > 0) and (10 > 5)

# 次は、どちらか成り立っていれば真になる`or`を使った例です。

# In[ ]:


(1 < 0) or (10 > 5)

# 最後は、真偽を逆にする`not`です。1は0より大きくないので、`1 < 0`自体は偽ですが、その真偽を逆にしているので、結果は真になっています。

# In[ ]:


not (1 < 0) 

# 真偽の判定は、以下のif文やループ処理で使いますので、しっかり理解しておきましょう。

# #### if文
# 
# 真偽判定を理解したところで、条件分岐を説明します。条件分岐とは、何かの条件で処理を分岐することで、if文を使います。
# ifの横に指定した条件式（真偽の判定式）を満たしている場合（`True`）は、該当の文（はじめにある`:`から`else:`の手前まで）が実行され、そうでない場合は`else:`以下が実行されます。つまり条件を満たすかどうかによって、処理を2分岐できます。
# 
# 以下の処理は、数字の「5」が`data_list`というリストの中に入っているかどうかを判定する例です。「findvalue in data_list」が判定式です。この`data_list`に5が入っていれば、すぐ下に書いてある処理が実行されます。一方、このリストに5が入っていなければ、`else`に飛びます。
# Pythonのコーディングにおける注意点ですが、`if`文などを使うとき、次の行はインデント（字下げ）します。通常は半角スペース4つ分を置きます。Jupyter環境では、改行をしたときに自動でインデントができますが、開発環境によっては異なるので注意してください。
# 
# if文の1行目:がif文の開始で、字下げがあるところまでが処理の対象です。elseの横にも：がありますので、これがelseの中身の処理が開始されることを意味しており、これも字下げがあるところまでが処理の対象で、そこでif文が終わります。他のプログラミング言語では、endなどがありますが、Pythonではそれを記載する必要がありません。字下げがなくなった個所から、if文の処理とは別の処理がはじまりますので、注意してください。

# In[ ]:


findvalue = 5

# if文の開始
if findvalue in data_list:
    #　条件式の結果が真の場合
    print('{0}は入っています。'.format(findvalue))
else:
    # 条件式の結果が偽の場合
    print('{0}は入っていません。'.format(findvalue))
# ここでif文は終わり

# 以下は、if文とは別の処理となる
print('ここから先はif文と関係なく、必ず表示されます')

# >**[やってみよう]**
# >
# >出力が変わるように、数字の設定（ここでは、`findvalue`）を変更して、実行してみましょう。また、条件文や、出力結果等を変えてみたりしてください。

# 結果を表示するときに用いた`'{0}は入っています'.format(findvalue)`という記法は、変数などの値を文字列に埋め込むための機能です。こうした埋め込み機能のことを文字列フォーマットと言います。他のプログラミング言語でも似た方法で使われます。
# ここで指定している`{0}`は、formatの括弧の最初に指定した値を埋め込む指定です。つまり、この場合は`findvalue`の値が埋め込まれます。
# formatの括弧のなかには、複数の値を指定することもできます。たとえば、次のように記述すると、`{0}`が2、`{1}`が3、`{2}`が5に対応して表示されます。括弧のなかに指定する値（ここでは`2, 3, 5`）のことを「引数（ひきすう）」と言います。後程、関数の節で改めて説明します。

# In[ ]:


print('{0} と {1} を足すと {2}です'.format(2,3,5))

# `{0}`や`{1}`、`{2}`のような埋め込む表記には、表示する桁数を指定するオプション表記もあります。詳しくは、`format`について調べてみてください。

# >** コラム　format記法と%記法 **
# >
# >本書では文字列をフォーマットするのに、`'文字列'.format(値, ...)`という記法を使います。この記法はformat記法と呼ばれ、Python 2.6で登場した記法です。
# >
# >それより前のバージョンのPythonからある文字列をフォーマットする記法として`%`記法があります。同じことを`%`記法を使って記述すると、次のように書けます。
# >
# > `print('%dは入っています。' % (findvalue)')`
# >
# >`%`記法は古い記法なので今後、廃止される可能性があります。ですから、これからプログラムを作るときは、`format`記法を使うようにしてください。

# #### for文
# 次に、繰り返し処理の構文を説明します。これは`for`文を使います。`for`文は、リストデータなどからデータを1つずつ取り出し、データがなくなるまで、繰り返し処理を実行します。
# 
# 以下の例は、`[1, 2, 3]`のリストデータに対して、先頭から順番に（1から）データを取り出し、データがなくなる（3まで）まで繰り返し処理（取り出した数字の表示と足し算）を実行しています。
# 
# 処理の初めは1を`num`に入れており、`0+1=1`となります。次に2を`num`に入れて`1+2=3`となり、最後に3を取り出して`3+3=6`となり、ここで`for`文が終わり、最終的な合計値を表示しています。なお、この`for`文も`if`文と同じように、`：`の以下から`for`文がはじまり、字下げがされているところまでが`for`文の処理対象となりますので、注意してください。

# In[ ]:


# 初期値の設定
total = 0

# for 文の開始
for num in [1, 2, 3]:
    # 取り出した数の表示
    print('num:', num)
    # 今まで取り出した数の合計
    total = total + num
# 以上で、for 文の終わり
    
# 最後に合計を表示
print('total:', total)

# 次の例は、`for`文を使って、先ほど作成した辞書型のキーを1つ1つ取り出して、それぞれのキーと値を出力するものです。これも、辞書型データのキーがなくなるまで繰り返します。

# In[ ]:


for dic_key in dic_data:
    print(dic_key, dic_data[dic_key])

# #### range関数を使った繰り返しリストの指定
# 連続した整数のリストを作りたいときは、1つ1つデータを入力してリストデータを作成していたら大変なので、以下のように`range`関数を使うと便利です。`range`関数では、数字としては、`N`を設定しますが、0から`N-1`が取り出される点に注意しましょう。以下では、`range`に値を11として設定していますが、最後に取り出される数字はその1つ手前の10までです。

# In[ ]:


# range(N)とすると0からN-1までの整数
for i in range(11):
    print(i)

# `range`関数では括弧のなかに「最初の値」「最後の値-1」「飛ばす値」を指定することができます。以下は、1から始めて11の手前まで、2つ飛ばしの要素を持つリストを作成しています。

# In[ ]:


# range(1, 11, 2)は1から開始して2つ飛ばしで、11の手前まで取り出す
for i in range(1, 11, 2):
    print(i)

# #### 複雑なfor文と内包表記
# 次に説明する話（内包表記など）は、Pythonの初学者には少し難易度が高いかもしれないので、はじめは読み流す程度で大丈夫です。
# 
# 辞書型データのキーと同時にその値を取り出すには、次の例のように記述します。これは、あとで説明する**オブジェクト指向型プログラミング**の特徴で、データ（ここでは`dic_data`）とそれを処理するための**メソッド**（以下の`items()`）がセットになっており、それを活用しています。メソッドとはあとで説明する**関数**みたいなもので、それを使って処理（ここでは、キーと値を返す処理）をします。

# In[ ]:


# キーと値を取り出して表示する
for key, value in dic_data.items():
    print(key, value)

# 次の例は`for`文を使って取り出したデータを、さらに別のリストとして結果を作成する方法で、**内包表記**といいます。先ほどやろうとしていた、リストの要素をそれぞれ2倍する処理です。
# 下記のサンプルにあるように、
# 
# `[i * 2 for i in data_list]`
# 
# と記述すると、`data_list`から値をひとつずつ取り出して変数`i`に格納します。1、2、3、、と取り出されて、それが変数`i`に入って、そしてその`i`を2倍した値で、新しいリストデータが作られます。その結果、リストの要素がすべて2倍になった新しいリストが作られます。

# In[ ]:


# 空のリストを作成
data_list1 = []

# 内包表記、data_listから1つ1つ要素を取り出し、2倍した数字を新たな要素とするリストを作成
data_list1 = [i * 2 for i in data_list]
print(data_list1)

# 内包表記では、条件を指定し、条件に合致するものだけを新しいリストの対象にすることもできます。
# たとえば`data_list`から、値が偶数である要素だけを取り出したいときは、以下のようにします。「`if i %2 ==0`」の部分が指定している条件です。「`%`」は余りを計算する演算子です。つまり、`i % 2`は、`i`を2で割った余りです。これが0であるということは偶数であるということを示します。

# In[ ]:


[i * 2 for i in data_list if i %2 ==0]

# #### zip関数
# また、`for`文に関連して、**`zip`関数**もよく使われるので、紹介します。
# `zip`関数は、それぞれ異なるリストを同時に取り出していく処理を実行します。たとえば、`[1,2,3]`というリストと、`[11,12,13]`という2つのリストがあるとき、それぞれ同じインデックスで値を取って表示したいとき――先頭の値である「1と11」、次の値である「2と12」、そして「3と13」のように繰り返して処理したいとき――は、次のようにします。

# In[ ]:


for one, two in zip([1, 2, 3], [11, 12, 13]):
    print(one, 'と', two)

# 異なるリストデータがあったとして、それぞれのインデックスがお互いに対応していて、同時に取り出して処理したい場合は、`zip`関数は便利です。

# #### while文を使った繰り返し処理
# 繰り返し処理をするには、`for`文以外に`while`文があります。`while`文は、条件が成り立っている間は、ずっと繰り返し処理する構文です。
# 次の例は、変数`num`の値を表示して、1ずつ加えていき、その値が10より大きくなった時点で、処理を終えるというものです。なお、こちらもif文やfor文と同じように：の行でwhile文がはじまり、字下げがあるところまでが処理の対象となります。

# In[ ]:


# 初期値の設定
num = 1 

# while文の開始
while num <= 10:
    print(num)
    num = num + 1
# while文の終わり
    
# 最後に代入された値を表示する
print('最後の値は{0}です'.format(num))

# ある条件で処理をストップさせたい（`while`文を抜けたい）ときには、`break`を使います。以下は、`num`の値が6を超えた時点で、`while`の処理から抜け出して、終了しています。なお、`if`文の`else`はなくてもよいですが、`else`を書いて何も処理を書かないとエラーになるので、単にその個所をスキップする`pass`を書いています。

# In[ ]:


# 初期値の設定
num =1 

# while文の開始
while num <= 10:
    num = num + 1
    
    # if文の開始
    if num > 6:
        print('6を超えました')
        break
    else:
        pass
    # if文の終わり
# while文の終わり

print('最後の値は{0}です'.format(num))

# 一方、ある条件で処理をさせて、ストップさせずにそのまま処理させたい（`while`文を続けたい）ときには、`continue`を使います。以下は、`num`の値が6を超えた時点で、'6を超えました'と表示されていますが、`while`文を抜けずに、そのまま処理を続けています。

# In[ ]:


# 初期値の設定
num =1 

# while文の開始
while num <= 10:
    num = num + 1
    
    # if文の開始
    if num > 6:
        print('6を超えました')
        continue
    else:
        pass
    # if文の終わり
# while文の終わり

print('最後の値は{0}です'.format(num))

# ### 1.2.5 関数
# キーワード：引数、返り値、関数、再帰、lambda関数、高階関数、map関数、apply関数
# 
# **関数**は一連の処理をひとまとめにする仕組みです。関数を作成すると、同じような処理を何度か実行したいときに、便利です。また、処理をまとめておくと、後でコードを修正するときにも便利です。
# 
# 下記に示す1つ目の`calc_multi`関数は、2つの数字（`a`と`b`）をインプット（これを**引数**といいます）として、その掛け算の結果を返す関数を作成しています。書き方としては、defの後に関数名、引数があれば、()の中に、引数名を記述します。この引数が入力となって、`return`で結果を返し（**返り値**といいます）、これが出力になります。

# In[ ]:


# 掛け算をする関数
def calc_multi(a, b):
    return a * b

# 関数を実行することを、関数を呼び出すと言います。作成した関数を呼び出すときには、関数名を書いて、引数が必要なときには、引数を与えて、実行します。以下は、引数として3と10を与えています。

# In[ ]:


calc_multi(3, 10)

# 関数は引数や返り値がなくてもかまいません。

# In[ ]:


def calc_print():
    print('printのサンプル関数')

# 上記の関数を呼び出すと、以下のように、関数の中にあるprint関数が実行されます。

# In[ ]:


calc_print()

# 次に示す関数は、フィボナッチ数を計算する例です。フィボナッチ数列とは、一歩手前と二歩手前の数を足して並べた数列のことをいいます（1, 1, 2, 3, 5...と前と前々の数字を足して、その数を並べたもの）。以下の関数`calc_fib`は、再帰と言って、自分の関数を中で呼び出しており、n番目のフィボナッチ数を作成しています。

# In[ ]:


# 再帰関数の例（フィボナッチ数）
def calc_fib(n):
    if n == 1 or n == 2:
        return 1
    else:
        return calc_fib(n - 1) + calc_fib(n - 2)

# 引数に10を与えて実行すると、そのフィボナッチ数は55になることがわかります。

# In[ ]:


print('フィボナッチ数:', calc_fib(10))

# 注意：このフィボナッチ数の処理方法は、再帰を理解してもらうために簡易に書きましたが、アルゴリズム（解法の手順）的には非常に効率が悪いので、大きな値を入力して実行すると計算結果が返ってこないので注意してください。興味のある方は、このアルゴリズムを改善するための方法を考えたり、実装してみてください。プログラミングは、計算結果は同じでも、処理方法は色々とあります。

# >**[やってみよう]**
# >
# >上記のようなフィボナッチ数を計算するための別の処理方法（可能なら改善する方法）を考えて、実装してしてみてください。

# **無名関数とmap**
# 
# 関数にはもう一つ、無名関数と呼ばれるものがあり、これを使うと、コードを簡素化できます。無名関数とは、その名前の通り、名前がない関数で、関数をその場に記述する記法です。
# 
# 無名関数を書くには、`lambda`というキーワードを使います。普通の関数を作るときと同じで、`lambda`と記述して引数を設定した後、その処理を記述します。
# 
# 例として、先に作成した掛け算をするcalc_multi関数を採り上げます。この関数は次のように、defで定義しておき、それから実行しました。

# In[ ]:


# calc_multi関数を定義
def calc_multi(a, b):
    return a * b

# それを実行
calc_multi(3, 10)

# `lambda`というキーワードを使って、その場で関数を記述する無名関数として書くと、このコードは、次のように書けます。

# In[ ]:


(lambda a, b: a * b)(3, 10)

# ここで`lambda a, b:`というのが、`関数名(a, b)`に相当する部分です。そして`:`で区切って、その関数の処理（ここでは`return a * b`）を記述するというのが、無名関数の基本的な書き方です。

# 無名関数は、リストなどの要素に対して何か関数を実行したいときに、よく使います。
# 
# 要素に対して、何か処理したいときは、`map`関数を使います。`map`関数は、**高階関数**と呼ばれ、関数を引数や戻り値として使う関数で、各要素に対して、何か処理や操作したいときに使います。
# 
# たとえば、次のように要素の値を2倍にして返す関数`calc_double`を定義するとします。

# In[ ]:


def calc_double(x) :
    return x * 2

# ここで、次のように`[1, 2, 3, 4]`というリストの要素に対して、この`calc_double`関数を実行したいとします。`for`文を使って書けば次のようになります。

# In[ ]:


for num in [1, 2, 3, 4]:
    print(calc_double(num))

# `map`関数を使うと、この処理をリストのまま処理でき、次のように書けます。

# In[ ]:


list(map(calc_double, [1, 2, 3, 4]))

# このような書き方だと、別に`calc_double`関数を定義しておかなければなりませんが、先に説明した無名関数を使うと、ここに直接関数の処理を記述でき、たとえば、次のように書けます。

# In[ ]:


list(map(lambda x : x * 2, [1, 2, 3, 4]))

# このように`map`関数や、6章で説明する`Pandas`機能などと一緒に使って、データの加工処理をするときに、よく使います。今はあまりメリットを感じられないでしょうが、後で使うので念頭に置いておいてください。

# 他にも、`reduce`関数や`filter`関数などもありますので、興味にある方は調べてみてください。

# >**[やってみよう]**
# >
# >`reduce`関数や`filter`関数について、その使い方等を調べて、何か実装してみましょう。

# #### <練習問題 1-1>
# 
# ある文字列（「Data Science」など）を変数に格納し、それを1文字ずつ表示させるプログラムを書いてください。

# #### <練習問題 1-2>
# 
# 1から50までの自然数の和を計算し、その計算結果を表示させるプログラムを書いてください。

# ### 1.2.6 クラスとインスタンス
# キーワード：オブジェクト、クラス、インスタンス、コンストラクタ

# 最後に、クラスとインスタンスについて説明します。
# はじめてこれらについて聞いた人は、すぐに理解するのは難しいと思います。ですから、以下の実装例を見て、雰囲気だけつかんでください。プログラミング初学者の人は、この節は、読み飛ばしてもかまいません。なぜなら、すぐには必要ないからです。ただし、あとの章で機械学習のライブラリであるSklearnなどを使うときに必要な概念（インスタンスなど）になるので、そのときには、この節に戻ってきてください。
# 
# Pythonはオブジェクト指向型のプログラミング言語です。クラスとは、「オブジェクトのひな型」のようなものです。
# よく挙げられる例が「たい焼き」です。以下のclassの`PrintClass`はたい焼き機の型を作っています。実際のたい焼きが出来上がったのがインスタンス`p1`というイメージです。インスタンスとは、クラスからできあがる実体のことです。インスタンスには属性を追加することができ、ピリオドで続けて任意の属性を指定できます。たとえば以下では、`p1.x`に10、`p1.y`に100、`p1.z`に1000を追加しています。
# 
# 参考までに、クラスとインスタンスのイメージ図も示しておきます。

# （※図は書籍を参照してください※）

# In[ ]:


# PrintClassクラスの作成とprint_meメソッド（関数）の作成
class PrintClass:
    def print_me(self):
        print(self.x, self.y)

# In[ ]:


# インスタンスの作成、生成
p1 = PrintClass()

# 属性の値を割り当て
p1.x = 10
p1.y = 100
p1.z = 1000

# メソッドの呼び出し
p1.print_me()

# p1というインスタンスに、`print_me()`という関数（メソッド）がついていて、それを呼び出して実行しています。新しく追加した属性の値`z`は以下のように確認できます。

# In[ ]:


# 先ほど追加した属性を表示
p1.z

# このオブジェクト指向とクラスの概念は少し難しいので、もう少し具体的な例を見てみましょう。
# 
# 以下はクラスとして`MyCalcClass`を作成しており、いくつかのメソッドを作っています。

# In[ ]:


class MyCalcClass:
    
    # 初期化
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def calc_add1(self, a, b):
        return a + b
    
    def calc_add2(self):
        return self.x + self.y

    def calc_mutli(self, a, b):
        return a * b

    def calc_print(self, a):
        print('data:{0}:yの値{1}'.format(a, self.y))

# 次に、このクラス（`MyCalcClass`）から、次のように2つのインスタンスを生成します。このとき、`instance_1`と`instance_2`は別物として扱われます。上記のたい焼きで例えると、チーズたい焼きとクリームたい焼きは別物ですよね。

# In[ ]:


instance_1 = MyCalcClass(1, 2)
instance_2 = MyCalcClass(5, 10)

# インスタンスを生成するときは、クラスに実装した「`__init__`」という名前の特別なメソッドが実行されます。これを
# コンストラクタと言います。コードには、「`self.x = x`」「`self.y = y`」という文があります。`self.`とは自分自身という意味です。そのため、この文によって、自身の`x`属性と`y`属性が、括弧のなかに指定した値になります。
# つまり上記の例では、`instanced_1`では、`MyCalcClass(1, 2)`としているので、`x`が1、`y`が2となります。同様に、`instance_2`の場合は`x`が5、`y`が10となります。
# 
# これらのインスタンスのメソッドを呼び出してみましょう。まずは、`instance_1`からです。

# In[ ]:


print('2つの数の足し算(新たに数字を引数としてセット):', instance_1.calc_add1(5, 3))
print('2つの数の足し算(インスタンス化の時の値):', instance_1.calc_add2())
print('2つの数のかけ算:', instance_1.calc_mutli(5, 3))
instance_1.calc_print(5)

# `calc_add1`は引数5と3を設定し、その和を返り値として算出しています。`calc_add2`は何も引数を指定しておらず、`self.x`と`self.y`の値を計算に使っています。この値は、先に説明したようにコンストラクタで設定されています。つまり、`instance_1 = MyCalcClass(1, 2)`では、その値は、それぞれ1と2として初期値が設定されるので、これらを足した3が表示されます。`calc_mutli`は引数の掛け算の結果、`instance_1.calc_print(5)`は、引数5と初期値として設定した`self.y`の方（2）を表示しています。

# `次は、`instance_2を使いましょう。上の`instance_1`のときの結果と値が変わります。なぜ変わっているのか、しっかりと追っていきましょう。

# In[ ]:


print('2つの数の足し算(新たに数字を引数としてセット):', instance_2.calc_add1(10, 3))
print('2つの数の足し算(インスタンス化の時の値):', instance_2.calc_add2())
print('2つの数のかけ算:', instance_2.calc_mutli(4, 3))
instance_2.calc_print(20)

# >**[やってみよう]**
# >
# >上のクラス（`MyCalcClass`）を使って、新しくインスタンスを生成し(`instance_3`など）、何か出力してみましょう。さらにできれば、異なるメソッド（2つの引数の差分など）をこのクラスに追加して、呼び出して使ってみましょう。

# これは見ているだけではわからないと思うので、上記の例をベースに、実際にサンプルコードなどを作成して実行しましょう。このクラス設計やその実装ができるようになると、大規模な開発をする場合に色々と役に立ちます。
# 

# 以上で、Pythonの基礎的なコードの説明は終わりです。Python初学者の人は慣れない部分もあったかと思いますが、もちろん、これだけでPythonの基礎を押さえるのは不十分です。
# もし基礎に不安があれば、参考文献「A-4」や参考URL「B-1」を見て復習などをしてください。「A-4」で紹介している『はじめてのPython』は分厚い本ですが、とても丁寧に説明されており、クラスやオブジェクト指向についてもしっかりと解説されているので、ぜひ読んでみてください。

# ## 1.3 総合問題

# ### ■ 総合問題1-1 素数判定
# 
# （1）10までの素数を表示するプログラムを書いてください。なお、素数とは、1とその数自身以外の約数をもたない正の整数のことをいいます。
# 
# （2）（1）をさらに一般化して、`N`を自然数として、`N`までの素数を表示する関数を書いてください。
